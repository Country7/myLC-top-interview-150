package main

/* Задача Элемент большинства
Дан массив nums размера n. Вернуть элемент большинства.
Элемент большинства — это элемент, который встречается более ⌊n / 2⌋ раз. Можно считать, что элемент большинства всегда присутствует в массиве.
Ограничения:
n == nums.length
1 <= n <= 5 * 10^4
-10^9 <= nums[i] <= 10^9 */

import (
	"fmt"
)

// ─────────────╮
/* Функция находит элемент, который встречается больше чем ⌊n/2⌋ раз в массиве nums.
Мы используем алгоритм Бойера–Мура, так как он работает за O(n) и требует только O(1) памяти.
Алгоритм работает не за счёт точного подсчёта, а за счёт парного исключения ("majority + чужой = 0").
Поскольку majority больше половины, он обязательно переживёт все исключения и в конце останется в candidate.  */
func majorityElement(nums []int) int {
	// Переменные для хранения текущего кандидата и счётчика
	candidate := 0
	count := 0
	fmt.Println("   ╰──> Инициализация candidate :=", candidate, ",  count :=", count)
	// Первый проход по массиву:
	// Ищем "кандидата" в мажоритарный элемент
	for _, num := range nums {
		if count == 0 {
			// Если счётчик обнулился — выбираем нового кандидата
			candidate = num
		}
		if num == candidate {
			count++ // если элемент совпал с кандидатом — увеличиваем счётчик
		} else {
			count-- // иначе уменьшаем счётчик
		}
		fmt.Println("     ╰──> num =", num, ",  candidate =", candidate, ",  count =", count)
	}
	// По условию задачи гарантируется, что majority элемент существует,
	// поэтому дополнительная проверка не требуется.
	return candidate
}

// ─────────────╯

// ─────────────╮
/* Второе решение:
Простое и понятное решение (через словарь / хэш-таблицу)
Это решение проще для понимания, особенно новичкам:
мы просто считаем, сколько раз встречается каждый элемент, и ищем тот, у кого количество больше n/2
Время O(n); Память O(n)  */

func majorityElementSimple(nums []int) int {
	// Создаём словарь (map) для подсчёта количества вхождений каждого числа
	counts := make(map[int]int)

	// Идём по массиву и считаем частоты
	for _, num := range nums {
		counts[num]++
		// Если текущий элемент встречается больше чем n/2 раз — можно сразу вернуть его
		if counts[num] > len(nums)/2 {
			return num
		}
	}

	// По условию задачи majority-элемент всегда существует
	return -1 // на всякий случай, но не будет достигнуто
}

// ─────────────╯

// ─────────────╮╰──>
func main() {
	fmt.Println()
	// Пример 1
	nums1 := []int{3, 2, 3}
	fmt.Println("Результат для [3,2,3]:", majorityElement(nums1), "\n ") // ожидаем 3
	// Пример 2
	nums2 := []int{2, 2, 1, 1, 1, 2, 2}
	fmt.Println("Результат для [2,2,1,1,1,2,2]:", majorityElement(nums2), "\n ") // ожидаем 2
	nums3 := []int{2, 2, 1, 1, 1, 1, 2, 2, 2, 1, 1, 2, 2}
	fmt.Println("Результат для ", nums3, ":", majorityElement(nums3), "\n ")                      //
	fmt.Println("Результат для ", nums3, "другим способом:", majorityElementSimple(nums3), "\n ") //
}
