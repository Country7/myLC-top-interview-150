package main

/* Задача Треугольник
Дан ​​массив треугольников, вернуть минимальную сумму пути сверху вниз.
На каждом шаге вы можете перейти на соседний элемент строки ниже. Более формально, если вы находитесь на индексе i в текущей строке, вы можете перейти либо на индекс i, либо на индекс i + 1 в следующей строке. */

import (
	"fmt"
)

// ─────────────╮
// Функция принимает треугольник и возвращает минимальную сумму пути от вершины до основания
func minPathSum(triangle [][]int) int {
	// Если треугольник пустой, возвращаем 0
	if len(triangle) == 0 {
		return 0
	}
	// Создаем срез dp, который будет хранить минимальные суммы для текущего уровня
	// Изначально он равен последней строке треугольника
	n := len(triangle)
	dp := make([]int, len(triangle[n-1]))
	copy(dp, triangle[n-1])
	fmt.Println("  ╰──> dp =", dp)
	// Идем снизу вверх, начиная со второй строки снизу
	for i := n - 2; i >= 0; i-- {
		for j := 0; j <= i; j++ {
			// Для каждой позиции берем минимальное значение между двумя возможными "потомками"
			// и прибавляем значение текущей позиции
			if dp[j] < dp[j+1] {
				dp[j] = triangle[i][j] + dp[j]
			} else {
				dp[j] = triangle[i][j] + dp[j+1]
			}
			fmt.Println("  ╰──> dp =", dp)
		}
	}
	// В dp[0] хранится минимальная сумма пути от вершины до основания
	return dp[0]
}

// ─────────────╯

// ─────────────╮╰──>
func main() {
	fmt.Println()
	triangle1 := [][]int{
		{2},
		{3, 4},
		{6, 5, 7},
		{4, 1, 8, 3},
	}
	fmt.Println("Минимальная сумма пути для triangle1:", minPathSum(triangle1)) // 11
	triangle2 := [][]int{
		{-10},
	}
	fmt.Println("Минимальная сумма пути для triangle2:", minPathSum(triangle2)) // -10
	fmt.Println()
}
