package main

/* ЗадачаЗмеи и лестницы
Вам дана доска с матрицей целых чисел n x n, клетки которой пронумерованы от 1 до n^2 в стиле бустрофедона, начиная с левого нижнего угла доски (т.е. board[n - 1][0]) и чередуя направление в каждой строке.
Вы начинаете с клетки 1 доски. При каждом ходе, начиная с клетки curr, выполните следующие действия:
Выберите клетку назначения next с меткой в ​​диапазоне [curr + 1, min(curr + 6, n^2)].
Этот выбор имитирует результат стандартного броска шестигранного кубика: то есть, всегда существует не более 6 точек назначения, независимо от размера доски.
Если на клетке next выпала змея или лестница, вы должны переместиться к этой клетке. В противном случае вы перемещаетесь на клетку next.
Игра заканчивается, когда вы достигаете клетки n^2.
На клетке доски в строке r и столбце c находится змея или лестница, если board[r][c] != -1. Конечная точка этой змеи или лестницы — board[r][c]. Клетки 1 и n^2 не являются начальными точками ни одной змеи или лестницы.
Обратите внимание, что вы берёте змею или лестницу не более одного раза за один бросок кубика. Если конечная точка змеи или лестницы является началом другой змеи или лестницы, вы не следуете за следующей змеей или лестницей.
Например, предположим, что поле имеет размер [[-1,4],[-1,3]], и на первом ходу ваша конечная точка — 2. Вы следуете по лестнице до клетки 3, но не следуете по следующей лестнице до клетки 4.
Верните наименьшее количество бросков кубика, необходимое для достижения клетки n^2. Если достичь клетки невозможно, верните -1. */

import (
	"container/list"
	"fmt"
)

// Функция для преобразования номера клетки (от 1 до n^2)
// в координаты матрицы (строка, колонка) с учётом "змейки" (Boustrophedon).
func numToPos(num, n int) (int, int) {
	// Определяем, на какой строке находится клетка. Индексация строк идёт сверху вниз (0...n-1),
	// но нумерация клеток идёт снизу вверх, поэтому нужно пересчитать.
	row := n - 1 - (num-1)/n
	// Колонка в строке.
	col := (num - 1) % n
	// Если строка идёт справа налево, то нужно "отзеркалить" колонку.
	if (n-row)%2 == 0 {
		col = n - 1 - col
	}
	return row, col
}

// ─────────────╮
// Основная функция для нахождения минимального числа ходов.
func snakesAndLadders(board [][]int) int {
	n := len(board)
	// Очередь для BFS (каждый элемент = номер клетки).
	queue := list.New()
	// Массив для отметки посещённых клеток.
	visited := make([]bool, n*n+1)
	// Начинаем с клетки 1 (первая клетка на поле).
	queue.PushBack(1)
	visited[1] = true
	moves := 0 // количество бросков кубика
	// Стандартный BFS
	for queue.Len() > 0 {
		size := queue.Len()
		for i := 0; i < size; i++ {
			curr := queue.Remove(queue.Front()).(int)
			// Если дошли до последней клетки — возвращаем количество ходов.
			if curr == n*n {
				return moves
			}
			// Симулируем броски кубика (от 1 до 6).
			for dice := 1; dice <= 6 && curr+dice <= n*n; dice++ {
				next := curr + dice
				r, c := numToPos(next, n)
				// Если на клетке есть лестница или змея — перемещаемся по ней.
				if board[r][c] != -1 {
					next = board[r][c]
				}
				// Если клетка ещё не посещалась, добавляем в очередь.
				if !visited[next] {
					visited[next] = true
					queue.PushBack(next)
				}
			}
		}
		// Увеличиваем количество бросков после прохода уровня BFS.
		moves++
	}
	// Если очередь опустела и мы не достигли конца — пути нет.
	return -1
}

// ─────────────╯

// ─────────────╮╰──>
func main() {
	fmt.Println()
	// Пример 1
	board1 := [][]int{
		{-1, -1, -1, -1, -1, -1},
		{-1, -1, -1, -1, -1, -1},
		{-1, -1, -1, -1, -1, -1},
		{-1, 35, -1, -1, 13, -1},
		{-1, -1, -1, -1, -1, -1},
		{-1, 15, -1, -1, -1, -1},
	}
	fmt.Println(snakesAndLadders(board1)) // Ожидается 4
	// Пример 2
	board2 := [][]int{
		{-1, -1},
		{-1, 3},
	}
	fmt.Println(snakesAndLadders(board2)) // Ожидается 1
	fmt.Println()
}
