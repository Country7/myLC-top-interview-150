package main

/* Задача Удаление дубликатов из отсортированного массива II
Дан массив целых чисел nums, отсортированный по неубыванию. Удалите некоторые дубликаты на месте так, чтобы каждый уникальный элемент встречался не более двух раз. Относительный порядок элементов должен оставаться неизменным.
Поскольку в некоторых языках невозможно изменить длину массива, необходимо поместить результат в первую часть массива nums. Более формально, если после удаления дубликатов осталось k элементов, то первые k элементов массива nums должны содержать конечный результат. Неважно, что останется после первых k элементов.
Верните k после размещения конечного результата в первых k ячейках массива nums.
Не выделяйте дополнительное место для другого массива. Для этого необходимо изменить входной массив на месте, выделив O(1) дополнительной памяти.   */

import (
	"fmt"
)

// ─────────────╮
// Функция удаляет дубликаты из отсортированного массива так, чтобы каждый элемент встречался максимум дважды.
// Функция возвращает k — длину массива после удаления лишних дубликатов.
func removeDuplicates(nums []int) int {
	// Индекс, куда будем записывать следующий допустимый элемент. Начинаем с 0, т.к. массив не пустой.
	k := 0
	// Проходим по всем элементам массива
	for i, num := range nums {
		if k > 2 {
			fmt.Println("  -──> index =", i, ", k =", k, ", num =", num, ", nums[k-2] =", nums[k-2], "--> nums[:k]", nums[:k])
		} else {
			fmt.Println("  -──> index =", i, ", k =", k, ", num =", num, "--> nums[:k]", nums[:k])
		}
		// Если k меньше 2, то просто записываем элемент,
		// потому что первые два элемента всегда можно оставить.

		if k < 2 || num != nums[k-2] {
			nums[k] = num // записываем элемент на правильную позицию
			k++           // увеличиваем длину результирующего массива
		}
		// Если num == nums[k-2], значит элемент встречается больше двух раз подряд
		// и мы его пропускаем
		if k > 2 {
			fmt.Println("  ╰──> index =", i, ", k =", k, ", num =", num, ", nums[k-2] =", nums[k-2], "--> nums[:k]", nums[:k])
		} else {
			fmt.Println("  ╰──> index =", i, ", k =", k, ", num =", num, "--> nums[:k]", nums[:k])
		}
	}
	return k // возвращаем длину массива после удаления лишних дубликатов
}

// ─────────────╯

// ─────────────╮╰──>
func main() {
	fmt.Println()
	// Пример 1
	nums1 := []int{1, 1, 1, 2, 2, 3}
	fmt.Println("Исходная nums =", nums1)
	k1 := removeDuplicates(nums1)
	fmt.Println("k =", k1)
	fmt.Println("nums =", nums1[:k1], "\n ")
	// Пример 2
	nums2 := []int{0, 0, 1, 1, 1, 1, 2, 3, 3}
	fmt.Println("Исходная nums =", nums2)
	k2 := removeDuplicates(nums2)
	fmt.Println("k =", k2)
	fmt.Println("nums =", nums2[:k2], "\n ")
	// Пример 3
	nums3 := []int{0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3}
	fmt.Println("Исходная nums =", nums3)
	k3 := removeDuplicates(nums3)
	fmt.Println("k =", k3)
	fmt.Println("nums =", nums3[:k3])

	fmt.Println()
}
