package main

/* Задача Удаление дубликатов из отсортированного массива II
Дан массив целых чисел nums, отсортированный по неубыванию. Удалите некоторые дубликаты на месте так, чтобы каждый уникальный элемент встречался не более двух раз. Относительный порядок элементов должен оставаться неизменным.
Поскольку в некоторых языках невозможно изменить длину массива, необходимо поместить результат в первую часть массива nums. Более формально, если после удаления дубликатов осталось k элементов, то первые k элементов массива nums должны содержать конечный результат. Неважно, что останется после первых k элементов.
Верните k после размещения конечного результата в первых k ячейках массива nums.
Не выделяйте дополнительное место для другого массива. Для этого необходимо изменить входной массив на месте, выделив O(1) дополнительной памяти.   */

import (
	"fmt"
)

// ─────────────╮
// Функция удаляет дубликаты из отсортированного массива так, чтобы каждый элемент встречался максимум дважды.
// Функция возвращает k — длину массива после удаления лишних дубликатов.
func removeDuplicates(nums []int) int {
	// Если длина массива меньше или равна 2 — ничего менять не нужно,
	if len(nums) <= 2 {
		return len(nums)
	}

	// k — индекс, куда мы будем записывать следующий допустимый элемент.
	// Первые два элемента всегда можно оставить как есть, поэтому начинаем с k = 2.
	k := 2

	// Проходим по массиву, начиная с третьего элемента (индекс 2),
	// потому что первые два элемента мы уже приняли без изменений.
	for i := 2; i < len(nums); i++ {

		// Сравниваем текущий элемент nums[i] с элементом nums[k-2]:
		// - nums[k-2] — это элемент, который стоит на 2 позиции до "текущего конца" результирующего массива.
		// Если nums[i] != nums[k-2], значит текущий элемент либо новый, либо встречается максимум второй раз — его записываем элемент на позицию k
		// Если nums[i] == nums[k-2], значит: текущий элемент уже встречался дважды — пропускаем его.
		if nums[i] != nums[k-2] {
			nums[k] = nums[i] // записываем элемент на позицию k (в результирующий массив)
			k++               // увеличиваем длину результирующей части
		}
	}

	// Возвращаем длину массива после удаления лишних дубликатов.
	// Все корректные элементы находятся в диапазоне nums[0:k].
	return k
}

// ─────────────╯

// ─────────────╮╰──>
func main() {
	fmt.Println()
	// Пример 1
	nums1 := []int{1, 1, 1, 2, 2, 3}
	fmt.Println("Исходная nums =", nums1)
	k1 := removeDuplicates(nums1)
	fmt.Println("k =", k1)
	fmt.Println("nums =", nums1[:k1], "\n ")
	// Пример 2
	nums2 := []int{0, 0, 1, 1, 1, 1, 2, 3, 3}
	fmt.Println("Исходная nums =", nums2)
	k2 := removeDuplicates(nums2)
	fmt.Println("k =", k2)
	fmt.Println("nums =", nums2[:k2], "\n ")
	// Пример 3
	nums3 := []int{0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3}
	fmt.Println("Исходная nums =", nums3)
	k3 := removeDuplicates(nums3)
	fmt.Println("k =", k3)
	fmt.Println("nums =", nums3[:k3])

	fmt.Println()
}
