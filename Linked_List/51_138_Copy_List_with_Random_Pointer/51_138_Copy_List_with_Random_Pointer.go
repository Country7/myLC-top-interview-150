package main

/* Задача Копирование списка со случайным указателем
Дан связный список длины n, в котором каждый узел содержит дополнительный случайный указатель, который может указывать на любой узел в списке или на NULL.
Создать полную копию списка. Полная копия должна состоять ровно из n совершенно новых узлов, где значение каждого нового узла равно значению соответствующего исходного узла. Как следующий, так и случайный указатель новых узлов должны указывать на новые узлы в скопированном списке таким образом, чтобы указатели в исходном и скопированном списках представляли одно и то же состояние списка. Ни один из указателей в новом списке не должен указывать на узлы исходного списка.
Например, если в исходном списке есть два узла X и Y, где X.random -> Y, то для соответствующих двух узлов x и y в скопированном списке x.random -> y.
Вернуть заголовок скопированного связного списка.
Связный список представлен на входе/выходе как список из n узлов. Каждый узел представлен парой [val, random_index], где:
val: целое число, представляющее Node.val
random_index: индекс узла (диапазон от 0 до n-1), на который указывает указатель random, или null, если он не указывает ни на один узел.
Ваш код получит только заголовок исходного связного списка. */

import (
	"fmt"
)

// Определение структуры узла связного списка
type Node struct {
	Val    int   // Значение узла
	Next   *Node // Указатель на следующий узел
	Random *Node // Дополнительный указатель на случайный узел (или nil)
}

// ─────────────╮
// Функция для копирования списка с произвольными ссылками
func copyRandomList(head *Node) *Node {
	if head == nil {
		return nil
	}
	// ЭТАП 1: Создание копий узлов и вставка их прямо после оригинальных
	// Например: A -> B -> C превратится в A -> A' -> B -> B' -> C -> C'
	cur := head
	for cur != nil {
		copyNode := &Node{Val: cur.Val} // создаём новый узел с тем же значением
		copyNode.Next = cur.Next        // связываем новый узел с "Next" оригинального
		cur.Next = copyNode             // вставляем новый узел сразу после оригинального
		cur = copyNode.Next             // двигаемся дальше (через новый узел)
	}

	// ЭТАП 2: Установка "Random" ссылок для копий
	cur = head
	for cur != nil {
		if cur.Random != nil {
			// cur.Next — это копия текущего узла
			// cur.Random.Next — это копия узла, на который указывает Random
			cur.Next.Random = cur.Random.Next
		}
		cur = cur.Next.Next // переходим к следующему оригинальному узлу
	}

	// ЭТАП 3: Разделение оригинального списка и скопированного
	cur = head
	newHead := head.Next // голова нового списка (первая копия)
	for cur != nil {
		copyNode := cur.Next     // копия текущего узла
		cur.Next = copyNode.Next // восстанавливаем ссылку оригинального списка
		if copyNode.Next != nil {
			copyNode.Next = copyNode.Next.Next // связываем копию со следующей копией
		}
		cur = cur.Next // двигаемся к следующему оригинальному узлу
	}
	return newHead
}

// Вспомогательная функция для печати списка в формате [[val, random_index], ...]
func printList(head *Node) {
	nodes := []*Node{}
	node := head
	for node != nil {
		nodes = append(nodes, node)
		node = node.Next
	}
	result := make([][2]interface{}, len(nodes))
	for i, n := range nodes {
		result[i][0] = n.Val
		if n.Random != nil {
			// Находим индекс узла, на который указывает Random
			for j, target := range nodes {
				if target == n.Random {
					result[i][1] = j
					break
				}
			}
		} else {
			result[i][1] = nil
		}
	}
	fmt.Println(result)
}

// ─────────────╯

// ─────────────╮╰──>
func main() {
	fmt.Println()
	// Создадим список вручную: [[7,null],[13,0],[11,4],[10,2],[1,0]]
	n1 := &Node{Val: 7}
	n2 := &Node{Val: 13}
	n3 := &Node{Val: 11}
	n4 := &Node{Val: 10}
	n5 := &Node{Val: 1}
	// Связываем "Next"
	n1.Next = n2
	n2.Next = n3
	n3.Next = n4
	n4.Next = n5
	// Связываем "Random"
	n2.Random = n1
	n3.Random = n5
	n4.Random = n3
	n5.Random = n1
	fmt.Println("Оригинальный список:")
	printList(n1)
	copied := copyRandomList(n1)
	fmt.Println("Скопированный список:")
	printList(copied)
	fmt.Println()
}
