package main

/* Задача Минимальная абсолютная разность в BST
Для корня двоичного дерева поиска (BST) вернуть минимальную абсолютную разность между значениями любых двух различных узлов в дереве.
Ограничения:
Количество узлов в дереве находится в диапазоне [2, 10^4].
0 <= Node.val <= 10^5.  */

/* Для понимания:
Минимальная абсолютная разница между значениями любых двух различных узлов в BST будет между двумя последовательными узлами при in-order обходе.

Рассмотрим дерево из примера 1: [4,2,6,1,3]
      4
     / \
    2   6
   / \
  1   3
In-order обход этого дерева: 1 → 2 → 3 → 4 → 6
Теперь вычислим разницы между последовательными узлами:
|2 - 1| = 1
|3 - 2| = 1
|4 - 3| = 1
|6 - 4| = 2
Минимальная разница равна 1.

Визуализация процесса по шагам алгоритма для этого дерева:
Начинаем с корня (4), идем влево к (2)
От (2) идем влево к (1) - это самый левый узел
Обрабатываем (1): prev = -1 → просто сохраняем значение 1 в prev
Возвращаемся к (2): вычисляем разницу 2-1=1, обновляем minDiff=1
Идем вправо от (2) к (3): вычисляем разницу 3-2=1, minDiff остается 1
Возвращаемся к (4): вычисляем разницу 4-3=1, minDiff остается 1
Идем вправо от (4) к (6): вычисляем разницу 6-4=2, minDiff остается 1
Результат: 1

Дополнительное объяснение
Если бы мы попытались найти минимальную разницу между непоследовательными узлами, например, между 1 и 3, разница была бы |3-1|=2, что больше чем 1. Между 1 и 4 разница |4-1|=3, еще больше. Таким образом, минимальная разница действительно всегда находится между соседними узлами в in-order обходе.
*/

import (
	"fmt"
	"math"
)

// Определение структуры узла бинарного дерева
type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

// ─────────────╮
// Функция для нахождения минимальной абсолютной разницы в BST
func getMinimumDifference(root *TreeNode) int {
	// Инициализация переменных

	// Для хранения значения предыдущего узла при обходе
	// Специальное значение, указывающее, что мы еще не обработали ни один узел
	prev := -1
	// Инициализируем максимально возможным значением, чтобы любая реальная разница была меньше
	minDiff := math.MaxInt32

	// Вспомогательная функция для рекурсивного обхода дерева в порядке in-order (левый-корень-правый)
	// Определяется как замыкание, чтобы иметь доступ к переменным prev и minDiff
	var traverse func(node *TreeNode)
	traverse = func(node *TreeNode) {
		if node == nil { // Условие выхода из рекурсии
			return
		}
		// Рекурсивный обход левого поддерева, сначала обрабатываем все меньшие значения
		traverse(node.Left)
		// Обработка текущего узла
		if prev != -1 { // Проверяем, есть ли предыдущее значение для сравнения
			// Вычисляем разницу между текущим и предыдущим узлом, (всегда положительную благодаря порядку обхода)
			diff := node.Val - prev
			if diff < minDiff {
				minDiff = diff // Обновляем минимальную разницу если нашли меньшую
			}
		}
		prev = node.Val // Сохраняем значение текущего узла как предыдущее для следующего сравнения
		// Рекурсивный обход правого поддерева, обрабатываем большие значения после текущего узла
		traverse(node.Right)
	}
	traverse(root) // Запускаем обход с корневого узла
	return minDiff // Возвращаем найденную минимальную разницу
}

// Вспомогательная функция для создания нового узла дерева
func newNode(val int) *TreeNode {
	return &TreeNode{Val: val}
}

// ─────────────╯

// ─────────────╮
func main() {
	fmt.Println()
	// Пример 1: [4,2,6,1,3]
	root1 := newNode(4)
	root1.Left = newNode(2)
	root1.Right = newNode(6)
	root1.Left.Left = newNode(1)
	root1.Left.Right = newNode(3)

	fmt.Println("Пример 1:")
	fmt.Printf("Минимальная абсолютная разница: %d\n", getMinimumDifference(root1)) // Ожидаемый результат: 1

	// Пример 2: [1,0,48,null,null,12,49]
	root2 := newNode(1)
	root2.Left = newNode(0)
	root2.Right = newNode(48)
	root2.Right.Left = newNode(12)
	root2.Right.Right = newNode(49)

	fmt.Println("\nПример 2:")
	fmt.Printf("Минимальная абсолютная разница: %d\n", getMinimumDifference(root2)) // Ожидаемый результат: 1
	fmt.Println()
}
