package main

/* Задача Корректная головоломка судоку
Определите, является ли доска судоку размером 9 x 9 корректной. Проверке подлежат только заполненные клетки в соответствии со следующими правилами:
Каждая строка должна содержать цифры от 1 до 9 без повторений.
Каждый столбец должен содержать цифры от 1 до 9 без повторений.
Каждый из девяти подполей сетки размером 3 x 3 должен содержать цифры от 1 до 9 без повторений.
Примечание:
Частично заполненная доска судоку может быть корректной, но не обязательно разрешимой.
Проверке подлежат только заполненные клетки в соответствии со следующими правилами. */

import (
	"fmt"
)

// ─────────────╮
// Функция  проверяет, является ли данная доска Sudoku валидной
func isValidSudoku(board [][]byte) bool {
	// Для удобства создаём три массива "множества" (maps),
	// где будем хранить встречающиеся цифры:
	// rows[i]   — хранит все цифры, встречающиеся в i-й строке
	// cols[j]   — хранит все цифры, встречающиеся в j-м столбце
	// boxes[k]  — хранит все цифры, встречающиеся в k-м 3x3 квадрате
	// Индекс квадрата k вычисляется по формуле: (i/3)*3 + j/3
	rows := make([]map[byte]bool, 9)
	cols := make([]map[byte]bool, 9)
	boxes := make([]map[byte]bool, 9)
	// Инициализация map для каждой строки, столбца и квадрата
	for i := 0; i < 9; i++ {
		rows[i] = make(map[byte]bool)
		cols[i] = make(map[byte]bool)
		boxes[i] = make(map[byte]bool)
	}

	// Проходим по каждой ячейке доски
	for i := 0; i < 9; i++ {
		for j := 0; j < 9; j++ {
			cell := board[i][j]
			// Если в клетке точка ".", значит она пустая — пропускаем
			if cell == '.' {
				continue
			}

			// Проверяем строку i
			if rows[i][cell] {
				// Если цифра уже есть в строке, Sudoku невалиден
				return false
			}
			rows[i][cell] = true

			// Проверяем столбец j
			if cols[j][cell] {
				// Если цифра уже есть в столбце, Sudoku невалиден
				return false
			}
			cols[j][cell] = true

			// Вычисляем индекс квадрата 3x3
			boxIndex := (i/3)*3 + j/3
			if boxes[boxIndex][cell] {
				// Если цифра уже есть в этом квадрате, Sudoku невалиден
				return false
			}
			boxes[boxIndex][cell] = true
		}
	}

	// Если все проверки пройдены — Sudoku валидный
	return true
}

// ─────────────╯

func prntSudoku(board [][]byte) {
	fmt.Println("Пример судоку:")
	for i := 0; i < 9; i++ {
		for j := 0; j < 9; j++ {
			fmt.Printf("%3s", string(board[i][j]))
		}
		fmt.Println()
	}
}

// ─────────────╮╰──>
func main() {
	fmt.Println()
	// Пример 1 — корректный Sudoku
	board1 := [][]byte{
		{'5', '3', '.', '.', '7', '.', '.', '.', '.'},
		{'6', '.', '.', '1', '9', '5', '.', '.', '.'},
		{'.', '9', '8', '.', '.', '.', '.', '6', '.'},
		{'8', '.', '.', '.', '6', '.', '.', '.', '3'},
		{'4', '.', '.', '8', '.', '3', '.', '.', '1'},
		{'7', '.', '.', '.', '2', '.', '.', '.', '6'},
		{'.', '6', '.', '.', '.', '.', '2', '8', '.'},
		{'.', '.', '.', '4', '1', '9', '.', '.', '5'},
		{'.', '.', '.', '.', '8', '.', '.', '7', '9'},
	}
	prntSudoku(board1)
	fmt.Println("Результат: ", isValidSudoku(board1), "\n ") // Ожидается: true

	// Пример 2 — некорректный Sudoku (два '8' в одном квадрате 3x3)
	board2 := [][]byte{
		{'8', '3', '.', '.', '7', '.', '.', '.', '.'},
		{'6', '.', '.', '1', '9', '5', '.', '.', '.'},
		{'.', '9', '8', '.', '.', '.', '.', '6', '.'},
		{'8', '.', '.', '.', '6', '.', '.', '.', '3'},
		{'4', '.', '.', '8', '.', '3', '.', '.', '1'},
		{'7', '.', '.', '.', '2', '.', '.', '.', '6'},
		{'.', '6', '.', '.', '.', '.', '2', '8', '.'},
		{'.', '.', '.', '4', '1', '9', '.', '.', '5'},
		{'.', '.', '.', '.', '8', '.', '.', '7', '9'},
	}
	prntSudoku(board2)
	fmt.Println("Результат: ", isValidSudoku(board2)) // Ожидается: false
	fmt.Println()
}
