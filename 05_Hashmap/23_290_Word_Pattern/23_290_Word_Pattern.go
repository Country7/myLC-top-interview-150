package main

/* Задача Шаблон слова
Для заданного шаблона и строки s определите, следует ли s тому же шаблону.
Здесь «следовать» означает полное совпадение, то есть, между буквой из шаблона и непустым словом из s существует биекция. А именно: Каждая буква из шаблона соответствует ровно одному уникальному слову из s.
Каждое уникальное слово из s соответствует ровно одной букве из шаблона.
Никакие две буквы не соответствуют одному и тому же слову, и никакие два слова не соответствуют одной и той же букве.

*/

import (
	"fmt"
	"strings"
)

// ─────────────╮
// Функция проверяет, соответствует ли строка s шаблону pattern
func wordPattern(pattern string, s string) bool {
	// Разбиваем строку s на слова по пробелам
	words := strings.Split(s, " ")
	// Если количество символов в шаблоне не совпадает с количеством слов,
	// то сразу возвращаем false — соответствия быть не может
	if len(pattern) != len(words) {
		return false
	}
	// Создаем две хэш-таблицы (map):
	// 1. Для соответствия символа из pattern слову
	// 2. Для соответствия слова символу (обратная проверка для уникальности)
	pToW := make(map[byte]string) // pattern -> word
	wToP := make(map[string]byte) // word -> pattern
	// Проходим по каждому символу шаблона и соответствующему слову
	for i := 0; i < len(pattern); i++ {
		ch := pattern[i] // символ шаблона
		word := words[i] // слово из строки s
		// Проверяем, есть ли уже соответствие символа ch слову
		if val, ok := pToW[ch]; ok {
			// Если символ уже сопоставлен с каким-то словом,
			// но это слово не совпадает с текущим, значит нарушение шаблона
			if val != word {
				return false
			}
		} else {
			// Если символ ch еще не встречался, проверим,
			// не сопоставлено ли это слово другому символу
			if val, ok := wToP[word]; ok {
				// Если слово уже связано с другим символом — нарушение условия биекции
				if val != ch {
					return false
				}
			}
			// Добавляем новое соответствие: символ -> слово и слово -> символ
			pToW[ch] = word
			wToP[word] = ch
		}
	}
	// Если прошли все проверки, значит строка соответствует шаблону
	return true
}

// ─────────────╯

// ─────────────╮╰──>
func main() {
	fmt.Println()
	// Примеры
	fmt.Println(wordPattern("abba", "dog cat cat dog"))  // true
	fmt.Println(wordPattern("abba", "dog cat cat fish")) // false
	fmt.Println(wordPattern("aaaa", "dog cat cat dog"))  // false
	fmt.Println(wordPattern("abba", "dog dog dog dog"))  // false
	fmt.Println()
}
