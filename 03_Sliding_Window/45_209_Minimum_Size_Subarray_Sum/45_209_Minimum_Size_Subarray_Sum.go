package main

/* Задача

 */

import (
	"fmt"
	"math"
)

// ─────────────╮
/* Функция находит минимальную длину подмассива, сумма элементов которого >= target
Используем два указателя: left (левая граница) и right (правая граница).
Расширяем окно вправо, добавляя элементы к сумме.
Когда сумма >= target, пробуем сдвинуть левую границу вправо, чтобы уменьшить длину подмассива.
Повторяем до конца массива.
Если минимальная длина так и не изменилась, возвращаем 0
*/
func minSubArrayLen(target int, nums []int) int {
	n := len(nums)
	minLen := math.MaxInt32 // Изначально задаём максимальное возможное значение
	sum := 0                // Текущая сумма подмассива
	left := 0               // Левая граница "окна"
	for right := 0; right < n; right++ {
		sum += nums[right] // Расширяем окно вправо, добавляя текущий элемент
		// Если и Пока сумма >= target, пытаемся сдвинуть левую границу вправо иначе двигается прававя граница
		for sum >= target {
			// Обновляем минимальную длину подмассива
			minLen = min(minLen, right-left+1)
			// Убираем элемент с левой границы и сдвигаем окно
			sum -= nums[left]
			left++
		}
	}
	// Если minLen не изменилось, значит подмассива нет
	if minLen == math.MaxInt32 {
		return 0
	}
	return minLen
}

// Вспомогательная функция для вычисления минимума из двух чисел
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// ─────────────╯

// ─────────────╮╰──>
func main() {
	fmt.Println()
	// Примеры из условия задачи
	fmt.Println(minSubArrayLen(7, []int{2, 3, 1, 2, 4, 3}))        // 2
	fmt.Println(minSubArrayLen(4, []int{1, 4, 4}))                 // 1
	fmt.Println(minSubArrayLen(11, []int{1, 1, 1, 1, 1, 1, 1, 1})) // 0
	fmt.Println()
}
