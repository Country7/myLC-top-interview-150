package main

/* Задача Sqrt(x)
Для заданного неотрицательного целого числа x вернуть квадратный корень x, округлённый до ближайшего целого числа. Возвращаемое целое число также должно быть неотрицательным.
Нельзя использовать встроенные функции или операторы возведения в степень.
Например, не используйте pow(x, 0.5) в C++ или x ** 0.5 в Python. */

import (
	"fmt"
)

// ─────────────╮
// Функция mySqrt принимает целое число x и возвращает целое число -
// квадратный корень от x, округленный вниз (floor).
func mySqrt(x int) int {
	// Граничный случай: если x равен 0 или 1, то ответ равен самому x. sqrt(0) = 0, sqrt(1) = 1
	if x < 2 {
		return x
	}
	// Устанавливаем начальные границы для бинарного поиска.
	// Левая граница (low) = 1, правая граница (high) = x/2
	// Почему x/2? Потому что квадратный корень от числа всегда <= x/2, если x > 1.
	low, high := 1, x/2
	var result int // переменная для хранения ответа

	for low <= high {
		// Находим середину отрезка
		mid := low + (high-low)/2
		// Чтобы избежать переполнения при mid*mid, используем деление.
		// Сравним mid с x/mid.
		if mid == x/mid {
			// Если mid^2 == x, то это точный квадратный корень.
			return mid
		} else if mid < x/mid {
			// Если mid^2 < x, то потенциальный ответ находится справа.
			// Сохраняем mid как возможный результат (так как mid^2 < x).
			result = mid
			low = mid + 1
		} else {
			// Если mid^2 > x, то ответ находится слева.
			high = mid - 1
		}
	}
	// Возвращаем наибольшее число, чей квадрат меньше или равен x
	return result
}

// ─────────────╯

// ─────────────╮╰──>
func main() {
	fmt.Println()
	// Примеры
	fmt.Println("mySqrt(4) = ", mySqrt(4))   // Ожидается: 2
	fmt.Println("mySqrt(8) = ", mySqrt(8))   // Ожидается: 2
	fmt.Println("mySqrt(0) = ", mySqrt(0))   // Ожидается: 0
	fmt.Println("mySqrt(1) = ", mySqrt(1))   // Ожидается: 1
	fmt.Println("mySqrt(15) = ", mySqrt(15)) // Ожидается: 3
	fmt.Println("mySqrt(16) = ", mySqrt(16)) // Ожидается: 4
	fmt.Println()
}
