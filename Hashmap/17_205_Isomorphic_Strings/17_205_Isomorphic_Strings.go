package main

/* Задача Изоморфные строки
Даны две строки s и t. Определите, являются ли они изоморфными.
Две строки s и t изоморфны, если символы в s можно заменить, чтобы получить t.
Все вхождения символа должны быть заменены другим символом с сохранением порядка символов. Никакие два символа не могут соответствовать одному и тому же символу, но символ может соответствовать самому себе. */

import (
	"fmt"
)

// ─────────────╮
// Компактная версия проверки изоморфности
func isIsomorphic(s string, t string) bool {
	// Длина строк: Если длины разные, они не могут быть изоморфными.
	if len(s) != len(t) {
		return false
	}
	// map для хранения последних индексов символов
	// Используется одна карта mapping для сопоставления символов s → t.
	// byte (alias для uint8) полностью подходит. Если бы строки могли содержать
	// Unicode (русские буквы, эмодзи и т.п.), пришлось бы использовать rune
	mapping := make(map[byte]int)
	// Карта seen проверяет, что символы t не повторяются для разных символов s.
	seen := make(map[byte]bool)

	for i := 0; i < len(s); i++ {
		// s[i] берёт i-й байт строки s, а t[i] — i-й байт строки t.
		// В контексте ASCII это удобно, так как каждый символ занимает ровно один байт.
		// Мы переменные, чтобы работать с символами коротко и удобно, без постоянного обращения к s[i] и t[i].
		char_s := s[i] // char_s — это текущий символ строки s на позиции i
		char_t := t[i] // char_t — это текущий символ строки t на той же позиции i

		// Если символ s уже сопоставлен
		if val, ok := mapping[char_s]; ok {
			// val — получаем это значение, связанное с ключом char_s (если оно есть).
			// ok — это логическое значение (bool), которое показывает, есть ли ключ char_s в карте.
			if val != int(char_t) { // если сопоставление отличается от текущего, возвращаем false
				return false
			}
		} else {
			// Если символ t уже был сопоставлен с другим символом s, false
			if seen[char_t] {
				return false
			}
			mapping[char_s] = int(char_t)
			seen[char_t] = true
		}
		fmt.Print("  ╰──> char_s = ", string(char_s), ",  char_t = ", string(char_t))
		fmt.Print("   ─>    mapping[char_s - ", string(char_s), "] = ", string(byte(mapping[char_s])))
		fmt.Println(",    seen[char_t - ", string(char_t), "] =", seen[char_t])
	}
	return true
}

// ─────────────╯

// ─────────────╮╰──>
func main() {
	var ex = [][]string{
		{"egg", "add"},     // true
		{"foo", "bar"},     // false
		{"paper", "title"}, // true
	}
	fmt.Println()
	for i := 0; i < len(ex); i++ {
		fmt.Println("\nСравниваем строки:", ex[i])
		fmt.Println("Результат:", isIsomorphic(ex[i][0], ex[i][1]))
	}
	fmt.Println()
}
